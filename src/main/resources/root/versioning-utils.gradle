import java.util.regex.Matcher
import java.util.regex.Pattern

class Versioning {

    private static final Map<String, Integer> typeOffsets = ["alpha": 0, "beta": 400, "RC": 700]
    private static final Pattern versionPattern = Pattern.compile("^([0-9]+)\\.([0-9]+)\\.([0-9]+)(?:-(.+))?\$")
    private static final Pattern suffixPattern = Pattern.compile("^([a-zA-Z]+)\\.([0-9]+)\$")
    private static final int MAX_BUILD_COUNTER = 999

    private static String runCommand(String command, Project project) {
        try {
            return command.execute([], project.rootDir).text.trim()
        } catch(Exception e) {
            // More likely the command is unavailable
            return ""
        }
    }

    private static int parseBuildNumber(String suffix) {
        Matcher matcher = suffixPattern.matcher(suffix)
        if (matcher.matches()) {
            return typeOffsets.getOrDefault(matcher.group(1).toLowerCase(), 0) + Integer.parseInt(matcher.group(2))
        } else {
            return 0
        }
    }

    private static Object resolve(String name, Project project) {
        if (project.hasProperty(name)) {
            return project.property(name)
        } else {
            throw new RuntimeException("Failed to resolve property: $name")
        }
    }

    public final int major
    public final int minor
    public final int patch
    public final String suffix
    public final int buildCounter
    public final String versionName
    public final int versionCode

    Versioning(Project project) {
        major = resolve("version_major", project) as Integer
        minor = resolve("version_minor", project) as Integer
        patch = resolve("version_patch", project) as Integer

        String tag = runCommand("git tag --points-at HEAD", project)
        Matcher matcher = versionPattern.matcher(tag)
        if (matcher.matches()) {
            // The current commit has been tagged, check it matches what has been defined in the source tree
            int tagMajor = Integer.parseInt(matcher.group(1))
            int tagMinor = Integer.parseInt(matcher.group(2))
            int tagPatch = Integer.parseInt(matcher.group(3))
            if (major != tagMajor || minor != tagMinor || patch != tagPatch) {
                throw new RuntimeException("Invalid tag name: expected $major.$minor.$patch but found $tagMajor.$tagMinor.$tagPatch")
            }

            String tagSuffix = matcher.group(4)
            if (tagSuffix != null) {
                // A suffix was found in the tag version, we infer the build number based on the suffix
                suffix = tagSuffix
                buildCounter = parseBuildNumber(tagSuffix)
            } else {
                // No suffix was found in the tag version, we therefore assume it is a final release
                suffix = ""
                buildCounter = MAX_BUILD_COUNTER
            }
        } else {
            // If the tage doesn't look like a release we just assume it is a snapshot
            String sha = runCommand("git rev-parse --short HEAD", project)
            suffix = '-SNAPSHOT' + sha
            buildCounter = 0
        }

        if (major > 99 || minor > 99 || patch > 99 || buildCounter > MAX_BUILD_COUNTER) {
            throw new RuntimeException("Version number overflow")
        }

        versionName = "$major.$minor.$patch$suffix"
        versionCode = (((major * 100 + minor) * 100) + patch) * 1000 + buildCounter
    }
}

if (!project.extensions.findByName("versioningUtils")) {
    project.extensions.create("versioningUtils", Versioning, project)
}